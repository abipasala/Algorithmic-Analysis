# -*- coding: utf-8 -*-
"""Algorithmic_Analysis_Lab4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lY01hVcyDX0ZRzGNJDq2VSswo59_YCXX
"""

#implimenting shortest path from given node to all nodes using BFS.

def bfs_shortest_path (graph, start):
  distance = {}
  current_layer = [start]
  next_layer = []
  distance [start] = 0
  while (current_layer):
    current_node = current_layer.pop(0)
    for neighbor in graph[current_node]:
      if neighbor not in distance:
        next_layer.append(neighbor)
        distance [neighbor] = distance [current_node] + 1
    if not current_layer:
      current_layer, next_layer = next_layer, []
  return distance

graph = {'A': ['B', 'D'],
        'B': ['A', 'C'],
        'C': ['B', 'G'],
        'D': ['A', 'E'],
        'E': ['D', 'F'],
        'F': ['E', 'G'],
        'G': ['C', 'F', 'H'],
        'H': ['G', 'I'],
        'I': ['H']
        }
dist_path = bfs_shortest_path(graph, 'A')
print(dist_path)

#implimenting shortest path from given node to all nodes using BFS.

def shortest_path_list (graph, start, end):
  queue = [(start, 0)]
  visited = set()
  visited.add(start)

  while queue:
    node, dist = queue.pop(0)
    if node == end:
      return dist
    for neighbor in graph[node]:
      if neighbor not in visited:
        visited.add(neighbor)
        queue.append((neighbor, dist + 1))
  return - 1

graph = {
      'A': ['B', 'C'],
      'B': ['A', 'C', 'D'],
      'C': ['A', 'B', 'E','F'],
      'D': ['B'],
      'E': ['C'],
      'F': ['C'],
}

print(shortest_path_list(graph, 'A', 'F'))

#DFS with recursion / Recursive DFS on a Graph

# Program 1: Recursive DFS (No Cycles)

def dfs_recursive(graph, node, visited=None):
    if visited is None:
        visited = set()
    visited.add(node)
    print(node)  # Process the node

    for neighbor in graph.get(node, []):
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited)

# Example graph (undirected or directed acyclic)
graph = {
        'A': ['B', 'D'],
        'B': ['A', 'C'],
        'C': ['B', 'G'],
        'D': ['A', 'E'],
        'E': ['D', 'F'],
        'F': ['E', 'G'],
        'G': ['C', 'F', 'H'],
        'H': ['G', 'I'],
        'I': ['H']
        }

print("DFS Recursive Traversal from node A:")
dfs_recursive(graph, 'B')

# Program 2: DFS with Cycle Detection in Directed Graph

def has_cycle(graph):
    visited = set()
    rec_stack = set()

    def dfs(node):
        if node in rec_stack:
            print(f"Cycle detected at node: {node}")
            return True  # Cycle found
        if node in visited:
            return False

        visited.add(node)
        rec_stack.add(node)

        for neighbor in graph.get(node, []):
            if dfs(neighbor):
                return True

        rec_stack.remove(node)
        return False

    for node in graph:
        if node not in visited:
            if dfs(node):
                return True
    return False

# Directed graph with a cycle: A → B → C → A
graph_with_cycle = {
    'A': ['B'],
    'B': ['C'],
    'C': ['A'],
    'D': ['E'],
    'E': []
}

print("\nChecking for cycles in directed graph:")
if has_cycle(graph_with_cycle):
    print("Cycle exists in the graph.")
else:
    print("No cycles in the graph.")

